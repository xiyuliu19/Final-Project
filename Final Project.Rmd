---
title: 'Final-Project: Tumor Microsatellite Instability classification of a melanoma
  case'
output:
  html_document:
    df_print: paged
---
# Xiyu Liu
# December, 6, 2019

## Description
The deliverable of this project is a HTML Notebook which shows the pipelines of conversing FASTQ files to MAF files. It also contains the application process of using an existing MSI classification pipeline — MSIpred to classify the MSI status of a melanoma case. What's more, the variant analysis and visualization are done by maftools package in R.

## Datasets
The data used for this project are pair-end sequencing FASTQ files. In the process, reference files are also needed for alignment and annotation.

## Proposed Analysis
The object of this project is getting tumor microsatellite instability classification of this melanoma case.

The first step is to converse FASTQ files to BAM files using BWA-MEM for alignment and samtools for format conversion.

Next, using Strelka to call variants, and this step can concerse BAM files to VCF files.

Then, annotating the useful VCF file by VEP, and using VCF2MAF to converse the VCF file to MAF file.

Then, using MSIpred to get the MSI prediction result.

Lastly, using R package maftools to analyze and visualize variants.

## Get data

### Log in the trgn sever and check the data

```{bash eval=FALSE}
cd /scratch/xiyuliu/unitTest_data
```

There are four files used for this study:
normal_L002_R1_001.fastq.gz
normal_L002_R2_001.fastq.gz
tumor_L001_R1_001.fastq.gz
tumor_L001_R2_001.fastq.gz

### Unzip the fastq files

Note: These are pair-end sequencing files.  

```{bash eval=FALSE}
gunzip normal_L002_R1_001.fastq.gz
gunzip normal_L002_R2_001.fastq.gz
gunzip tumor_L001_R1_001.fastq.gz
gunzip tumor_L001_R2_001.fastq.gz
```

Here, we get normal_L002_R1_001.fastq, normal_L002_R2_001.fastq, tumor_L001_R1_001.fastq, and tumor_L001_R2_001.fastq.

## From FASTQ to BAM

Note: The FASTQ file stores reads from NGS. There are no positional relationships between the two reads next to each other in the FASTQ file, they are reads randomly derived from a certain position in the original genome. Therefore, we need to organize these reads, compare them with the reference genome of the species one by one, find the position of each read on the reference genome, and then separate them in order. This process is called alignment.

### Install BWA

Note: BWA is a software that maps DNA sequences to a reference genome, such as mapping to the human genome. It combines the BW (Burrows-Wheeler) compression algorithm with a suffix tree, which allows us to obtain accurate sequence alignment results at a small time and space cost. It consists of three algorithms BWA-backtrack, BWA-SW and BWA-MEM. The first algorithm is designed for Illumina sequence reads up to 100bp, while the rest two for longer sequences ranged from 70bp to a few megabases. BWA-MEM and BWA-SW share similar features such as the support of long reads and chimeric alignment, but BWA-MEM, is generally recommended as it is faster and more accurate. BWA-MEM also has better performance than BWA-backtrack for 70-100bp Illumina reads.

```{bash eval=FALSE}
mkdir bwa
cd bwa
git clone https://github.com/lh3/bwa.git   
cd bwa  
make
```

### Download alignment reference data

Note: hg series, hg18/19/38 from UCSC is the most frequently used genome. This study uses hg38 which is currently the latest version released in 2013.

```{bash eval=FALSE}
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/hg38.fa.gz   
gunzip hg38.fa.gz  
```

Here, we get a fasta file called "hg38.fa".

### Run BWA-MEM for alignment

```{bash eval=FALSE}
./bwa index hg38.fa  
./bwa mem hg38.fa normal_L002_R1_001.fastq normal_L002_R2_001.fastq | gzip -3 > normal-aln-pe.sam.gz   
./bwa mem hg38.fa tumor_L001_R1_001.fastq tumor_L001_R2_001.fastq | gzip -3 > tumor-aln-pe.sam.gz   
gunzip normal-aln-pe.sam.gz   
gunzip tumor-aln-pe.sam.gz   
```

The outputs are two SAM files called "normal-aln-pe.sam" and "tumor-aln-pe.sam".

We get SAM files in this stage, but we need BAM files. Both are the format of the fastq file after sequence alignment. SAM is a sequence file with alignment information, and is a generic format for storing large nucleotide sequence alignments. While BAM is the compressed binary version of the SAM format. Binary files in biological information are mainly used to save space and can be read by a computer. We can use samtools to convert between sam and bam files.

### Install samtools(v.1.6)

```{bash eval=FALSE}
wget https://github.com/samtools/samtools/releases/download/1.6/samtools-
 1.6.tar.bz2
 cd samtools-1.6
 ./configure
 make   
```

### Run samtools
```{bash eval=FALSE}
samtools view -b -S normal-aln-pe.sam > normal-aln-pe.bam   
samtools view -b -S tumor-aln-pe.sam > tumor-aln-pe.bam   
```

The outputs are two BAM files called "normal-aln-pe.bam" and "tumor-aln-pe.bam".

Check the BAM files:
Firstly, make sure the BWA operation ends without any error.
Secondly, use samtools to check the integrity of the BAM files.

```{bash eval=FALSE}
samtools quickcheck normal-aln-pe.bam && echo "all ok" \
   || echo "fail!"
samtools quickcheck tumor-aln-pe.bam && echo "all ok" \
   || echo "fail!"
```

Here, we get "all ok", it means that we have successfully processed the FASTQ files to BAM files. 

## From BAM to VCF

Note: This is the process of variant calling, using tools to directly compare each site of a tumor-normal sample, marking the suballeles that are significantly higher than the normal sample in the tumor sample as somatic mutations, and excluding germline Mutation and loss of heterozygosity (LOH). Strelka reports the most likely genotype for tumor and normal samples based on a Bayesian probability model and is specifically designed for clinical. It can detect SNV and INDEL, support multiple alleles, and it is fast and accurate.  

### Install Strelka
```{bash eval=FALSE}
wget https://github.com/Illumina/strelka/releases/download/v2.8.2/strelka-2.8.2.centos5_x86_64.tar.bz2   
tar xvfj strelka-2.8.2.centos5_x86_64.tar.bz2 
```

### Prepare the properate files for Strelka

Note: The BAM files output after BWA alignment are out of order, we need to sort the BAM files for next steps. We use samtools to do it. 

```{bash eval=FALSE}
samtools sort normal-aln-pe.bam > normal-sorted.bam   
samtools sort tumor-aln-pe.bam > tumor-sorted.bam   
samtools index normal-sorted.bam   
samtools index tumor-sorted.bam   
```

Here, we get two nem BAM files called "normal-sorted.bam" and "tumor-sorted.bam".

### Run Strelka for variant calling

```{bash eval=FALSE}
/home/xiyuliu/bwa/strelka-2.8.2.centos5_x86_64/bin/configureStrelkaSomaticWorkflow.py --normalBam normal-sorted.bam --tumorBam tumor-sorted.bam --referenceFasta hg38.fa --runDir demo_somatic --exome   
./home/xiyuliu/bwa/strelka-2.8.2.centos5_x86_64/bin/demo_somatic/runWorkflow.py -m local -j 8   
gunzip somatic.indels.vcf.gz   
gunzip somatic.snvs.vcf.gz     
```

The outputs are two VCF files called "somatic.indels.vcf" and "somatic.snvs.vcf".

Check the generated VCF files:
Firstly, make sure the Strelka operation ends without any error.
Secondly, view the VCF files and compare the columns of them with the output sample provided by Strelka.

Here, we have successfully processed the BAM files to VCF files.

Because we want to classify the tumor microsatellite instability statu, we only need to considerate the snv variant, we will only use the somatic.snvs.vcf file for next steps.

### Extract and generate a VCF file with only filtered "PASS" variants

Note: During the process of SNP calling, the data has been properly filtered, three instructions will be given as to whether the filtering is completed: one is to give the mutation sites that have not passed the filtering with a description of "low qulaity"; the second is that the "PASS" indicates that all the filters have passed the filtering; the third "." is that the site has not passed any filtering. Here, we only keep the filtered "PASS" variants because they have high credibility.

```{bash eval=FALSE}
awk -F '\t' '{if($0 ~ /\#/) print; else if($7 == "PASS") print}' somatic.snvs.vcf > somatic_snvs_PASS.vcf    
```

The output is a new VCF file called "somatic_snvs_PASS.vcf" with only filtered "PASS" variants.

### Annotate VCF file

Note: VEP is provided by ENSEMBL, one of the three major international databases. It is a very mainstream and convenient annotation tool. It can provide powerful and detailed mutation annotation information. To be specific, it provides more specific annotations on genetic variation information, not just based on loci and genes. In addition, I tried other annatation tools such as SnpEff and Annovar. But the output annatation VCF file generated by SnpEff and annovar can not be used by vcf2maf which is a tool for conversing the VCF format to MAF format. The vcf2maf is worked with VEP.

### Install VEP for annotation

Reminder: The VEP is working in the environment of Perl, please check if your already have Perl installed. 

```{bash eval=FALSE}
git clone https://github.com/Ensembl/ensembl-vep.git   
cd ensembl-vep   
cpanm Try::Tiny  
cpanm DBD::mysql  
curl -L http://cpanmin.us | perl - --notest -l $PERL_PATH LWP::Simple LWP::Protocol::https Archive::Extract Archive::Tar Archive::Zip CGI DBI Time::HiRes --force   
perl INSTALL.pl   
y  #Do you want to install any cache files (y/n)?   
y  #Cache directory /home/xiyuliu/.vep does not exists - do you want to create it (y/n)?   
320  #The following species/files are available; which do you want (can specify multiple separated by spaces or 0 for all)?   
y  #Do you want to install any FASTA files (y/n)?   
85  #FASTA files for the following species are available; which do you want (can specify multiple separated by spaces, "0" to install for species specified for cache download)?   
y  #Do you want to install any plugins (y/n)?   
y  #Plugins directory /home/xiyuliu/.vep/Plugins does not exists - do you want to create it (y/n)?   
0  #The following plugins are available; which do you want (can specify multiple separated by spaces or 0 for all)?     
```

## From VCF to MAF

Note: Generating a MAF file is a formatting process. The mutation annotation format contains somatic mutation information and is widely used in cancer research. In this study, the MSIpred package used to classify the tumor microsatellite instability status needs MAF file as the input file format.


```{bash eval=FALSE}
mkdir vcf2maf   
```

### Install vcf2maf

Download the source code of the latest stable release from https://github.com/mskcc/vcf2maf/releases.

Upload it to the sever.

```{bash eval=FALSE}
scp /Users/Liu/vcf2maf-1.6.17.zip xiyuliu@trgn.usc.edu:/home/xiyuliu/vcf2maf/   
```

```{bash eval=FALSE}
cd vcf2maf
gunzip vcf2maf-1.6.17.zip
cd vcf2maf-1.6.17   
```

### Download the files needed to support operation

```{bash eval=FALSE}
wget ftp://ftp.broadinstitute.org/pub/ExAC_release/current/subsets/ExAC_nonTCGA.r0.3.1.sites.vep.vcf.gz     
```

Here, we got a VCF file called "ExAC_nonTCGA.r0.3.1.sites.vep.vcf.gz".

### Run VEP and vcf2maf 

Note: The annatation and file format conversion are processing at the same time with one command line.

```{bash eval=FALSE}
perl vcf2maf.pl --input-vcf somatic_snvs_PASS.vcf --output-maf somatic_snvs_PASS.maf --ref-fasta hg38.fa --filter-vcf ExAC_nonTCGA.r0.3.1.sites.vep.vcf.gz --vep-path ../ensembl-vep --vep-data ~/.vep --ncbi-build GRCh38    
```

The outputs are one VCF file called "somatic_snvs_PASS.vep.vcf" and one MAF file called "somatic_snvs_PASS.maf".

Check the generated MAF file:
Firstly, make sure the vcf2maf operation ends without any error.
Secondly, view the output MAF file and check the format is same with the official MAF.
Thirdly, check there is annatation in the file.
Fourthly, find the pathogenic variant (NM_004333.6(BRAF):c.1799T>A (p.Val600Glu)).

```{bash eval=FALSE}
grep "c.1799T>A" somatic_snvs_PASS.maf    
```

Here, we have successfully processed the VCF file to MAF file.

## Classify Tumor Microsatellite Instability of this melanoma case by MSIpred

Note: Microsatellite instability (MSI) is characterized by a high degree of polymorphism in microsatellite lengths due to deficiency in mismatch repair (MMR) system. MSI is associated with several tumor types and its status can be considered as an important indicator for patient prognosis. The MSIpred, a python package for automatic MSI classification using a machine learning technology – support vector machine (SVM). MSIpred computes 22 features characterizing tumor somatic mutational load from mutation data in mutation annotation format (MAF) generated from paired tumor-normal exome sequencing data, subsequently using these features to predict tumor MSI status with a SVM classifier trained by MAF data of 1074 tumors belonging to MSS (a combination of MSI-L and MSS) tumors and MSI-H tumors. 

### Install Prerequisites

Note: The package needs python 2 >= 2.7 pandas >= 0.20.3 intervaltree >=2.1.0 sklearn >= 0.19.1 to operate.

```{bash eval=FALSE}
pip install -U scikit-learn==0.19.1 --user
pip install -U intervaltree==2.1.0 --user   
pip install -U pandas==0.20.3 --user       
```

### Install MSIpred package

Get MSIpred from Github:

```{bash eval=FALSE}
git clone https://github.com/wangc29/MSIpred.git    
```

```{bash eval=FALSE}
cd MSIpred
python setup.py install --user    
```

### Download required database

```{bash eval=FALSE}
wget http://hgdownload.cse.ucsc.edu/goldenPath/hg38/database/simpleRepeat.txt.gz 
gunzip simpleRepeat.txt.gz
```

Here, we get a TXT file called "simpleRepeat.txt".

### Preparation of the input MAF file for MSIpred

Note: In my maf file (somatic_snvs_PASS.maf), there are individual items that contain some special values other than "chr1","chr2","chr3","chr4","chr5","chr6","chr7","chr8","chr9","chr10","chr11","chr12","chr13","chr14","chr15","chr16","chr17","chr18","chr19","chr20","chr21","chr22","chrX", and "chrY" in the chromosome column, we need to filter them out first, otherwise an error will be reported of the "Chromosome".

I Create a python script (filter.py) to filter out the special values.

```{bash eval=FALSE}
vi filter.py   
```
```{bash eval=FALSE}
#!/usr/bin/python   
   
from __future__ import print_function

maf = "somatic_snvs_PASS.maf"

chrs = {"chr1":1,"chr2":1,"chr3":1,"chr4":1,"chr5":1,"chr6":1,"chr7":1,"chr8":1,"chr9":1,"chr10":1,
		"chr11":1,"chr12":1,"chr13":1,"chr14":1,"chr15":1,"chr16":1,"chr17":1,"chr18":1,"chr19":1,
		"chr20":1,"chr21":1,"chr22":1,"chrX":1,"chrY":1}

with open(maf) as mfin,open("somatic_snvs_PASS_filter_by_chr.maf","w") as outf:
	h1 = mfin.readline().strip()
	h2 = mfin.readline().strip()
	print(h1,file=outf)
	print(h2,file=outf)
	for line in mfin:
		content = line.strip().split("\t")
		if content[4] in chrs:
			print(line.strip(),file=outf)   
```

```{bash eval=FALSE}
chmod 755 filter.py   
./filter.py   
```

The output is a new MAF file called "somatic_snvs_PASS_filter_by_chr.maf".

### Run MSIpred to get the prediction result

```{python.reticulate = FALSE}
python
>>> import MSIpred as mp   
>>> snvs_maf = mp.Raw_Maf(maf_path='somatic_snvs_PASS_filter_by_chr.maf')   
>>> snvs_maf.create_tagged_maf(ref_repeats_file='simpleRepeat.txt',tagged_maf_file = 'tagged_snvs.maf')   
>>> tagged_snvs_maf = mp.Tagged_Maf(tagged_maf_path='tagged_snvs.maf')   
>>> snvs_features = tagged_snvs_maf.make_feature_table(exome_size=44)   
>>> predicted_MSI = mp.msi_prediction(feature_table=snvs_features,svm_model=None)   
>>> predicted_MSI.to_csv('MSIpred_prediction.csv')
>>> quit()
```

The outputs are one file called "tagged_snvs.maf" and one file called "MSIpred_prediction.csv".

Check the generated CSV file:
As it is showed in the file, the MSI classification status of this melanoma case is MSS.

Here, we have successfully predicted the MSI status of this melanoma case.

## Variant Analysis and Visualization

### Preparation steps:

1. Open RStudio

Note: The R version is 3.6.1 (2019-07-05).

2. Set the working directory  
  
```{r}
setwd('/Users/Liu/')
```

3. Install maftools Package  
  
```{r}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("maftools")
library(maftools)
```

4. Load the MAF file into a dataframe

```{r}
snvs_maf = read.maf(maf ='~/Desktop/somatic_snvs_PASS_filter_by_chr.maf')
```

### Plot MAF Summary

The dashboard style includes statistics for "Variant Classification", "Variant Type", "SNV Class", "Variants per sample", "Variant Classification summary", and "Top 10 mutated genes". To be specific, the figure shows the number of variants in this sample as a stacked bar chart and the variant types as a box chart of the Variant_Classification summary.


```{r}
plotmafSummary(maf = snvs_maf, rmOutlier = TRUE, addStat = 'median')
```

### Lollipop plot

Lollipop plot is the simplest and most effective way to show mutations in protein structure. It shows the protein's domains and the location and type of amino acid mutations of the pathogenic gene mutation. Many oncogenes have priority sites that mutate more frequently than any other locus. These spots are considered mutation hotspots, and a lollipop plot can be used to show them as well as other mutations. 
  
In this study, the variant located in the BRAF gene were considered to be pathogenic variant. I found the pathogenic variant NM_004333.6(BRAF):c.1799T>A (p.Val600Glu) in Chr7:140753336 in the ClinVar. This variant causes a protein change of V600E. The same variant is found in this case. 
  
So we can use the function lollipopPlot to draw such a plot. This function requires that we have the amino acid change information in the maf file. We will use the parameter AACol and manually specify it as HGVSp_Short in this study.

```{r}
lollipopPlot(snvs_maf, gene="BRAF", AACol="HGVSp_Short", showMutationRate=TRUE)
```

### Rainfall plot 

The plot is mostly used for detecting mutation hotspots in cancer genomics by visualizing the distribution of somatic point mutations along a reference genome. In this plot, each event is a mutation. The x-coordinate shows the genomic position of the mutation, while the y-coordinate represents the base pair distance between consecutive mutations on a logarithmic scale. In other words, it shows hyper mutated genomic region in chromosome-scale mutation spacing.

After running, the specific information of Kataegis will be output and marked with black arrows in the figure. "Kataegis" is defined as a genomic segment containing ≥6 consecutive mutations, and the average distance between mutations is ≤100bp.

```{r}
rainfallPlot(maf= snvs_maf, detectChangePoints=TRUE, pointSize=0.6)
```

### TMB calculation and TCGA cohorts comparison

TMB means tumor mutation burden, it is the variants per sample. Using the tcgaComapare function directly can count the TMB of the MAF file and compare it with the 33 built-in TCGA cohorts.  

```{r}
luad.mutload <- tcgaCompare(maf= snvs_maf)
```

Issue: We can see that there are 47938 mutations in this melanoma case. But the MSIpred package reports a MSS classification for this case. A problem arises here, why is the sample with such high mutations classified as tumor microsatellite stability. According to Bethesda guideline4, tumors are termed as microsatellite stable (MSS) if none of five loci tested is mutated, and tumors are termed as microsatellite instability low (MSI-L) if only one tested locus is mutated and microsatellite instability-high (MSI-H) if two or more tested loci are mutated. So, one possible reason is that the mutations in this case did not occur in the five loci tested. What's more, according to the MSIpred literature, the pan-tumor support vector machine classifier with a radial basis function kernel for MSI classification using the aforementioned 22 features of all tumors from the training set. Therefore, another possibility is that this MSIpred tool is not accurate, and its application has limitations. In the MSIpred literature, it shows that this tool predicts tumor MSI status through tumor mutation information obtained by exome sequencing. So, maybe this tumor microsatellite instability classification tool does not work in our case. Although I strictly followed its usage process, it gives wrong classification results due to its own shortcomings.

### Visualization of VAF

Variant Allele Frequency is the ratio of the read coverage depth that supports alternate / mutant allele at a certain position in the genome to the total read coverage depth of this site. The plotVaf function can display several genes with the highest VAF in boxplots.

```{r}
plotVaf(maf= snvs_maf)
```

### pfam annotations and statistics

The function pfamDomains can be used to annotate the pfam domain where the mutation that caused the amino acid change is located and the statistical results based on the pfam domain (stored in luad.pfam $ proteinSummary and luad.pfam $ domainSummary respectively), and draw a scatter plot. The dots represent the pfam domain, the corresponding X-axis is the number of mutations in the domain, and the Y-axis and the size of the dots are the number of genes affected. In this study, we set the parameter top to 10, meaning there are 10 pfam domains with the most mutations showing in the plot.

```{r}
luad.pfam <- pfamDomains(maf= snvs_maf, AACol="HGVSp_Short", top=10)
luad.pfam$proteinSummary[,1:7, with=FALSE]
luad.pfam$domainSummary[,1:3, with=FALSE]
```

All Done!